package com.zero.oauth.client.core.oauth1;

import com.zero.oauth.client.core.properties.PropertyModel;
import com.zero.oauth.client.type.FlowStep;
import com.zero.oauth.client.type.SignatureMethod;

import lombok.Getter;

/**
 * It is model to define an OAuth parameter when sending request OAuth server.
 *
 * @see PropertyModel
 */
@Getter
public final class OAuth1RequestProperty extends OAuth1PropertyModel {

    /**
     * Realm.
     */
    public static final OAuth1RequestProperty REALM =
        new OAuth1RequestProperty("realm").declare(FlowStep.REQUEST, Constraint.OPTIONAL)
                                          .declare(FlowStep.AUTHORIZE, Constraint.OPTIONAL)
                                          .declare(FlowStep.EXCHANGE_TOKEN, Constraint.OPTIONAL)
                                          .declare(FlowStep.ACCESS_RESOURCE, Constraint.OPTIONAL);

    /**
     * An absolute URI back to which the server will redirect the resource owner when the Resource Owner
     * Authorization step is completed.
     */
    public static final OAuth1RequestProperty REDIRECT_URI =
        new OAuth1RequestProperty("oauth_callback").declare(FlowStep.REQUEST);

    /**
     * The public identifier for the application, obtained when the developer first registered the
     * application.
     */
    public static final OAuth1RequestProperty CONSUMER_KEY =
        new OAuth1RequestProperty("oauth_consumer_key").declare(FlowStep.REQUEST)
                                                       .declare(FlowStep.EXCHANGE_TOKEN)
                                                       .declare(FlowStep.ACCESS_RESOURCE);

    /**
     * The private secret for the application, obtained when the developer first registered the application.
     * <p>
     * The {@code shared-secret} will be used with {@code temp credential} to combine a {@code OAuth
     * signature} for identify request.
     *
     * @see #SIGNATURE_METHOD
     * @see #SIGNATURE
     * @see OAuth1ResponseProperty#TOKEN
     */
    public static final OAuth1RequestProperty CONSUMER_SECRET =
        new OAuth1RequestProperty("oauth_consumer_secret").declare(FlowStep.REQUEST)
                                                          .declare(FlowStep.EXCHANGE_TOKEN)
                                                          .declare(FlowStep.ACCESS_RESOURCE);

    /**
     * The name of the signature method used by the client to sign the request.
     *
     * @see SignatureMethod
     */
    public static final OAuth1RequestProperty SIGNATURE_METHOD =
        new OAuth1RequestProperty("oauth_signature_method").declare(FlowStep.REQUEST)
                                                           .declare(FlowStep.EXCHANGE_TOKEN)
                                                           .declare(FlowStep.ACCESS_RESOURCE)
                                                           .setValue(SignatureMethod.HMAC_SHA1);

    /**
     * The client generates a signature and use it together with {@link #SIGNATURE_METHOD}.
     */
    public static final OAuth1RequestProperty SIGNATURE =
        new OAuth1RequestProperty("oauth_signature").declare(FlowStep.REQUEST)
                                                    .declare(FlowStep.EXCHANGE_TOKEN)
                                                    .declare(FlowStep.ACCESS_RESOURCE);

    /**
     * The timestamp is expressed in the number of seconds since January 1, 1970 00:00:00 GMT. The timestamp
     * value MUST be a positive integer and MUST be equal or greater than the timestamp used in previous
     * requests.
     */
    public static final OAuth1RequestProperty TIMESTAMP =
        new OAuth1RequestProperty("oauth_timestamp").declare(FlowStep.REQUEST)
                                                    .declare(FlowStep.EXCHANGE_TOKEN)
                                                    .declare(FlowStep.ACCESS_RESOURCE);

    /**
     * A nonce is a random string, uniquely with that {@link #TIMESTAMP} generated by the client to allow the
     * server to verify that a request has never been made before and helps prevent replay attacks when
     * requests are made over a non-secure channel.
     */
    public static final OAuth1RequestProperty NONCE =
        new OAuth1RequestProperty("oauth_nonce").declare(FlowStep.REQUEST).declare(FlowStep.EXCHANGE_TOKEN)
                                                .declare(FlowStep.ACCESS_RESOURCE);

    /**
     * If present, value MUST be {@code 1.0}.
     */
    public static final OAuth1RequestProperty VERSION =
        new OAuth1RequestProperty("oauth_version").declare(FlowStep.REQUEST, Constraint.OPTIONAL)
                                                  .declare(FlowStep.EXCHANGE_TOKEN, Constraint.OPTIONAL)
                                                  .declare(FlowStep.ACCESS_RESOURCE, Constraint.OPTIONAL)
                                                  .setValue("1.0");

    /**
     * The token is used in 2 cases.
     * <ul>
     * <li>{@code Request Token}: The temporary credentials token to exchange it for
     * {@code Access Token}.</li>
     * <li>{@code Access Token}: Used by the Consumer(client) to access the Protected Resources on behalf of
     * the Resource Owner.</li>
     * </ul>
     */
    public static final OAuth1RequestProperty TOKEN =
        new OAuth1RequestProperty("oauth_token").declare(FlowStep.AUTHORIZE).declare(FlowStep.EXCHANGE_TOKEN)
                                                .declare(FlowStep.ACCESS_RESOURCE);

    /**
     * The verification code.
     */
    public static final OAuth1RequestProperty OAUTH_VERIFIER =
        new OAuth1RequestProperty("oauth_verifier").declare(FlowStep.AUTHORIZE)
                                                   .declare(FlowStep.EXCHANGE_TOKEN);

    public OAuth1RequestProperty(String name) {
        super(name);
    }

    private OAuth1RequestProperty(OAuth1RequestProperty property) {
        super(property);
    }

    @SuppressWarnings("unchecked")
    @Override
    public OAuth1RequestProperty duplicate() {
        return new OAuth1RequestProperty(this);
    }

}
